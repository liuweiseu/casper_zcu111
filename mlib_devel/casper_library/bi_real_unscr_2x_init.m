function bi_real_unscr_2x_init(blk, varargin)
% Initialize and configure a bi_real_unscr_2x block.
% 
% bi_real_unscr_2x_init(blk, varargin)
% 
% blk = the block to configure
% varargin = {'varname', 'value', ...} pairs
% 
% Valid varnames:
% * FFTSize = Size of the FFT (2^FFTSize points).
% * n_bits = Data bitwidth.
% * add_latency = Latency of adders blocks.
% * conv_latency = Latency of cast blocks.
% * bram_latency = Latency of BRAM blocks.
% * bram_map = Store map in BRAM.
% * dsp48_adders = Use DSP48s for adders.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%   Center for Astronomy Signal Processing and Electronics Research           %
%   http://casper.berkeley.edu                                                %
%   Copyright (C) 2010 William Mallard                                        %
%                                                                             %
%   SKASA                                                                     %
%   www.kat.ac.za                                                             %
%   Copyright (C) 2013 Andrew Martens                                         %
%                                                                             %
%   This program is free software; you can redistribute it and/or modify      %
%   it under the terms of the GNU General Public License as published by      %
%   the Free Software Foundation; either version 2 of the License, or         %
%   (at your option) any later version.                                       %
%                                                                             %
%   This program is distributed in the hope that it will be useful,           %
%   but WITHOUT ANY WARRANTY; without even the implied warranty of            %
%   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the             %
%   GNU General Public License for more details.                              %
%                                                                             %
%   You should have received a copy of the GNU General Public License along   %
%   with this program; if not, write to the Free Software Foundation, Inc.,   %
%   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.               %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Set default vararg values.
% reg_retiming is not an actual parameter of this block, but it is included
% in defaults so that same_state will return false for blocks drawn prior to
% adding reg_retiming='on' to some of the underlying Delay blocks.
defaults = { ...
    'n_inputs', 1, ...
    'FFTSize', 4, ...
    'n_bits', 18, ...
    'bin_pt', 17, ...
    'async', 'off', ...
    'add_latency', 1, ...
    'conv_latency', 1, ...
    'bram_latency', 2, ...
    'bram_map', 'on', ...
    'dsp48_adders', 'off', ...
    'reg_retiming', 'on', ...
};

% Skip init script if mask state has not changed.
if same_state(blk, 'defaults', defaults, varargin{:}), return; end

% Verify that this is the right mask for the block.
check_mask_type(blk, 'bi_real_unscr_2x');

% Disable link if state changes from default.
munge_block(blk, varargin{:});

% Retrieve values from mask fields.
n_inputs      = get_var('n_inputs', 'defaults', defaults, varargin{:});
FFTSize       = get_var('FFTSize', 'defaults', defaults, varargin{:});
n_bits        = get_var('n_bits', 'defaults', defaults, varargin{:});
bin_pt        = get_var('bin_pt', 'defaults', defaults, varargin{:});
async         = get_var('async', 'defaults', defaults, varargin{:});
add_latency   = get_var('add_latency', 'defaults', defaults, varargin{:});
conv_latency  = get_var('conv_latency', 'defaults', defaults, varargin{:});
bram_latency  = get_var('bram_latency', 'defaults', defaults, varargin{:});
bram_map      = get_var('bram_map', 'defaults', defaults, varargin{:});
dsp48_adders  = get_var('dsp48_adders', 'defaults', defaults, varargin{:});

if FFTSize == 0 | n_inputs == 0,
  delete_lines(blk);
  clean_blocks(blk);
  save_state(blk, 'defaults', defaults, varargin{:});
  return;
end

% Generate reorder maps.
map_even = bit_reverse(0:2^(FFTSize-1)-1, FFTSize-1);
map_odd = bit_reverse(2^(FFTSize-1)-1:-1:0, FFTSize-1);

%%%%%%%%%%%%%%%%%%
% Start drawing! %
%%%%%%%%%%%%%%%%%%

% Delete all lines.
delete_lines(blk)

%
% Add inputs and outputs.
%

reuse_block(blk, 'sync', 'built-in/inport', 'Position', [15 13 45 27], 'Port', '1');
reuse_block(blk, 'even', 'built-in/inport', 'Position', [15 138 45 152], 'Port', '2');
reuse_block(blk, 'odd', 'built-in/inport', 'Position', [15 263 45 277], 'Port', '3');

reuse_block(blk, 'sync_out', 'built-in/outport', ...
  'Position', [575 18 605 32], 'Port', '1');
reuse_block(blk, 'pol13_out', 'built-in/outport', ...
    'Position', [575 138 605 152], 'Port', '2');
reuse_block(blk, 'pol24_out', 'built-in/outport', ...
    'Position', [575 168 605 182], 'Port', '3');

%
% Add reorder blocks.
%

reuse_block(blk, 'reorder_even', 'casper_library_reorder/reorder', ...
    'Position', [100 82 175 158], 'map', mat2str(map_even));
add_line(blk, 'sync/1', 'reorder_even/1');
add_line(blk, 'even/1', 'reorder_even/3');

reuse_block(blk, 'reorder_odd', 'casper_library_reorder/reorder', ...
    'Position', [100 207 175 283], 'map', mat2str(map_odd));
add_line(blk, 'sync/1', 'reorder_odd/1');
add_line(blk, 'odd/1', 'reorder_odd/3');

for name = {'even', 'odd'},
  set_param([blk,'/reorder_',name{1}], ...
    'n_inputs', '1', 'bram_latency', num2str(bram_latency), ...
    'map_latency', '1', 'double_buffer', '0', 'bram_map', bram_map);
end

if strcmp(async, 'on'),
  reuse_block(blk, 'en', 'built-in/inport', 'Position', [15 113 45 127], 'Port', '4');
  add_line(blk, 'en/1', 'reorder_even/2');
  add_line(blk, 'en/1', 'reorder_odd/2');

  reuse_block(blk, 'dvalid', 'built-in/outport', 'Position', [575 63 605 77], 'Port', '4');
else
  reuse_block(blk, 'en_even', 'xbsIndex_r4/Constant', ...
      'Position', [15 110 45 130], ...
      'ShowName', 'off', ...
      'arith_type', 'Boolean', ...
      'const', '1', ...
      'n_bits', '1', ...
      'bin_pt', '0', ...
      'explicit_period', 'on', ...
      'period', '1');
  add_line(blk, 'en_even/1', 'reorder_even/2');

  reuse_block(blk, 'en_odd', 'xbsIndex_r4/Constant', ...
      'Position', [15 235 45 255], ...
      'ShowName', 'off', ...
      'arith_type', 'Boolean', ...
      'const', '1', ...
      'n_bits', '1', ...
      'bin_pt', '0', ...
      'explicit_period', 'on', ...
      'period', '1');
  add_line(blk, 'en_odd/1', 'reorder_odd/2');
end

reuse_block(blk, 't0', 'built-in/Terminator', 'Position', [235 110 255 130]);
add_line(blk, 'reorder_even/2', 't0/1');
reuse_block(blk, 't1', 'built-in/Terminator', 'Position', [235 210 255 230]);
add_line(blk, 'reorder_odd/1', 't1/1');
reuse_block(blk, 't2', 'built-in/Terminator', 'Position', [200 235 220 255]);
add_line(blk, 'reorder_odd/2', 't2/1');

%
% Add misc logic.
%

reuse_block(blk, 'count', 'xbsIndex_r4/Counter', ...
    'Position', [250 4 295 31], ...
    'ShowName', 'off', ...
    'cnt_type', 'Free Running', ...
    'cnt_to', 'Inf', ...
    'operation', 'Up', ...
    'start_count', '0', ...
    'cnt_by_val', '1', ...
    'arith_type', 'Unsigned', ...
    'n_bits', num2str(FFTSize-1), ...
    'bin_pt', '0', ...
    'load_pin', 'off', ...
    'rst', 'on', ...
    'en', async, ...
    'explicit_period', 'on', ...
    'period', '1', ...
    'use_behavioral_HDL', 'on', ...
    'implementation', 'Fabric');...


if strcmp(async, 'on'), 
  reuse_block(blk, 'l0', 'xbsIndex_r4/Logical', ...
    'logical_function', 'AND', 'inputs', '2', 'latency', '0', ...
    'Position', [200 87 225 118]);
  add_line(blk, 'reorder_even/1', 'l0/1');
  add_line(blk, 'reorder_even/2', 'l0/2');
  
  add_line(blk, 'l0/1', 'count/1');
  add_line(blk, 'reorder_even/2', 'count/2');
else,
  add_line(blk, 'reorder_even/1', 'count/1');
end

reuse_block(blk, 'constant', 'xbsIndex_r4/Constant', ...
    'Position', [255 37 275 53], ...
    'ShowName', 'off', ...
    'arith_type', 'Unsigned', ...
    'const', '0', ...
    'n_bits', num2str(FFTSize-1), ...
    'bin_pt', '0', ...
    'explicit_period', 'on', ...
    'period', '1');

reuse_block(blk, 'relational', 'xbsIndex_r4/Relational', ...
    'Position', [315 7 365 58], ...
    'ShowName', 'off', ...
    'mode', 'a=b', ...
    'latency', '0');

add_line(blk, 'count/1', 'relational/1');
add_line(blk, 'constant/1', 'relational/2');

reuse_block(blk, 'd0', 'xbsIndex_r4/Delay', ...
    'Position', [270 260 300 280], ...
    'latency', '1', ...
    'en', async, ...
    'reg_retiming', 'on');
add_line(blk, 'reorder_odd/3', 'd0/1');

reuse_block(blk, 'mux', 'xbsIndex_r4/Mux', ...
    'Position', [400 162 425 228], ...
    'inputs', '2', ...
    'en', 'off', ...
    'latency', '1', ...
    'Precision', 'Full');
add_line(blk, 'relational/1', 'mux/1');
add_line(blk, 'reorder_even/3', 'mux/3');
add_line(blk, 'd0/1', 'mux/2');

reuse_block(blk, 'sync_delay', 'xbsIndex_r4/Delay', ...
    'Position', [485 15 515 35], ...
    'ShowName', 'on', ...
    'latency', 'add_latency + conv_latency + 1', ...
    'reg_retiming', 'on');
add_line(blk, 'sync_delay/1', 'sync_out/1');

reuse_block(blk, 'even_delay', 'xbsIndex_r4/Delay', ...
    'Position', [400 135 430 155], ...
    'ShowName', 'on', ...
    'latency', '1', ...
    'reg_retiming', 'on');
add_line(blk, 'reorder_even/3', 'even_delay/1');

if strcmp(async, 'on'),
  add_line(blk, 'l0/1', 'sync_delay/1');
  
  add_line(blk, 'reorder_odd/2', 'd0/2');

  reuse_block(blk, 'en_delay', 'xbsIndex_r4/Delay', ...
      'Position', [485 60 515 80], ...
      'latency', 'add_latency + conv_latency + 1', ...
      'reg_retiming', 'on');
  add_line(blk, 'reorder_even/2', 'en_delay/1');
  add_line(blk, 'en_delay/1', 'dvalid/1');
else
  add_line(blk, 'reorder_even/1', 'sync_delay/1');
end

%
% Add hilbert block.
%

reuse_block(blk, 'hilbert', 'casper_library_ffts_internal/hilbert', ...
    'Position', [475 131 525 189], ...
    'n_inputs', num2str(n_inputs), ...
    'BitWidth', 'n_bits', ...
    'bin_pt_in', 'bin_pt', ...
    'add_latency', 'add_latency', ...
    'conv_latency', 'conv_latency', ...
    'misc', 'off');

add_line(blk, 'even_delay/1', 'hilbert/1');
add_line(blk, 'mux/1', 'hilbert/2');

add_line(blk, 'hilbert/1', 'pol13_out/1');  
add_line(blk, 'hilbert/2', 'pol24_out/1');  

% Delete all unconnected blocks.
clean_blocks(blk);

%%%%%%%%%%%%%%%%%%%
% Finish drawing! %
%%%%%%%%%%%%%%%%%%%

% Save block state to stop repeated init script runs.
save_state(blk, 'defaults', defaults, varargin{:});

